// Feather disable all

///	Constructor that creates a new instance of a Binder
///
///	@param data				Array with the source data for the index
///	@param map_fn			Mapping function to be used on data entries to generate the index and sorting
///	@param [build_index]	Whether to build the index directly on creation (default: false)
///
///	*** Public variables
/// 
///	map_fn					Mapping function passed on creation
///	index					Array with references (indexes) to the data, sorted based on the mapping function (undefined if not built)
///	size					Size of the index (0 if not built)
/// data					Reference to the source data
///
///	*** Public methods
///	
///	build_index()			Creates or recreates the index based on the data
/// find(value, [map_value], [eval_fn])
///							Binary search for a single value
/// from_json(json_string)	Assigns the index from a json string (as generated by to_json) instead of building it
/// get_ref(i)				Returns the reference of the value at position i in the index
///	get_val(i)				Returns the (mapped) value from the source data indexed at position i
/// get_val_raw(i)			Returns the value from the source data indexed at position i
/// load(filename)			Synchronously load the binde from file
/// save(filename)			Synchronously saves the binder to file
/// search(value, [map_value], [eval_fn])
///							Binary search for multiple values
///	to_json([pretty])		Returns a json representation of the index

function Binder(_data, _map_fn, _build_index = false) constructor {
	
	data		= _data;
	map_fn		= _map_fn;
	index		= undefined;
	size		= 0;

	#region private

	static __assert_built = function() {
		if(is_undefined(index)) {
			__binder_error("Binder index has not been built");
		}
	}

	static __sort_fn = function(_a, _b) {
		_a = map_fn(data[_a]);
		_b = map_fn(data[_b]);
		
		return (_a > _b) - (_a < _b);
	}
	
	#endregion

	#region public
	
	static build_index = function() {
		index = array_create_ext(array_length(data), function(_i) { return _i; });
		array_sort(index, method(self, __sort_fn));
		size = array_length(index);
	}
	
	static find = function(_value, _map_value = false, _eval_fn = undefined) {
		__assert_built();
		
		if(_map_value) {
			_value = map_fn(_value);
		}
	
		return __binder_binary_search(self, _value, _eval_fn, false);; 
	}
	
	static from_json = function(_json_string) {
		var _json = undefined;
		
		try {
	        _json = json_parse(_json_string);
			
			switch(_json.version) {
				default:
				case "1.0.0":
					index	= _json.index;
					size	= array_length(index);
				break;
			}
			
			return true;
	    } 
		
		catch (_e) {
			if(BINDER_SHOW_WARN) { __binder_trace("Failed to load binder from json string") };
	        return false;
	    }
    }
	
	static get_ref = function(_i) {
		return index[_i];
	}
	
	static get_val = function(_i) {
		return map_fn(data[index[_i]]);
	}
	
	static get_val_raw = function(_i) {
		return data[index[_i]];
	}
	
	static load = function(_filename) {
		if(!file_exists(_filename)) {
			if(BINDER_SHOW_WARN) { __binder_trace($"File {_filename} doesn't exist"); }
			return false;
		}
		
		var _buffer = buffer_load(_filename);
		
		if(is_undefined(_buffer)) {
			if(BINDER_SHOW_WARN) { __binder_trace($"Failed to load binder from {_filename}") };
			return false;
		}
		
		var _json_string = buffer_read(_buffer, buffer_text);
		buffer_delete(_buffer);
		
		return from_json(_json_string);			
	}
	
	static save = function(_filename) {
		__assert_built();
		
		var _json	= to_json();
		var _buffer	= buffer_create(string_byte_length(_json), buffer_fixed, 1);
		
		buffer_write(_buffer, buffer_text, _json);
		buffer_save(_buffer, _filename);
		buffer_delete(_buffer);
	}
	

	
	static search = function(_value, _map_value = false, _eval_fn = undefined) {
		__assert_built();
		
		if(_map_value) {
			_value = map_fn(_value);
		}
	
		return __binder_binary_search(self, _value, _eval_fn, true);	 
	}

	static to_json = function(_pretty = false) {
		__assert_built();
		
		var _struct = {
			version: BINDER_VERSION,
			index: index
		}
		
		return json_stringify(_struct, _pretty);
	}
		
	#endregion

	if(_build_index) {
		build_index();
	}

}